分别基于邻接矩阵和邻接表，实现了图结构的建立方法和搜索算法，支持无向图和有向图。

#### 运行方法：

- 进入当前文件夹
- CMake .
- make
- ./hw3

#### 文件结构：

> . 为当前文件夹，==高亮==的为源程序文件，**加粗**的为测试数据和结果数据

| 路径                   | 说明                                                         |
| ---------------------- | ------------------------------------------------------------ |
| ./support/queue.h      | 队列的实现，使用于广度优先搜索算法（复用了作业二的代码）     |
| ./support/stack.h      | 栈的实现，使用于深度优先搜索算法（复用了实验一的代码）       |
| ./CMakeLists.txt       | CMake文件，用于构建项目                                      |
| ./forest.h             | 森林（树）的实现，用于存储和展示先深/先广生成森林（树）      |
| ==./graph.h==          | 图类的声明，包括抽象类 vGraph，基于邻接矩阵的 Matrix::Graph ，基于邻接表的 List::Graph |
| ==./graph_list.cpp==   | 基于邻接表的图的所有方法的实现                               |
| ==./graph_matrix.cpp== | 基于邻接矩阵的图的所有方法的实现                             |
| **./in.txt**           | 图的建立算法中，重定向输入到此文件                           |
| ==./main.cpp==         | 建立了两个图，并调用 test.h 的函数对各方法进行测试           |
| **./out.txt**          | 保存了程序运行的输出                                         |
| ./README.md            | 本文件                                                       |
| ./README.pdf           | 本文件（转为pdf）                                            |
| ==./test.h==           | 测试用的模板函数                                             |
| ./图L.png              | 测试邻接表存储方法的图，有向图                               |
| ./图M.png              | 测试邻接矩阵存储方法的图，无向图                             |

#### 作业完成情况：

1. *分别实现无向图（或有向图）的邻接矩阵和邻接表存储结构的建立算法，分析和比较各建立算法的时间复杂度以及存储结构的空间占用情况。*

   **算法的实现位于下面的方法中：**

   ```C++
   void List::Graph<V, E, directed>::create();
   void Matrix::Graph<V, E, directed>::create();
   ```

   **分析和比较：**

   存储结构的建立主要分两部分：输入顶点和输入边。对于邻接矩阵存储，输入顶点的时间复杂度为 $\rm O(n)$，初始化邻接矩阵的复杂度为 $\rm O(n^2)$，输入邻接边的时间为 $\rm O(e)$，由 $\rm e\ll n$ 得总时间复杂度 $\rm T= O(n^2)$。因为存了 $\rm n$ 个顶点以及一个 $\rm n\times n$ 的矩阵，所以空间占用情况 $\rm S=O(n^2)$。

   对于邻接表存储，输入顶点的时间复杂度同样为 $\rm O(n)$，输入边采用头插法，时间复杂度 $\rm O(e)$，总时间复杂度 $\rm O(n)$。因为存了 $n$ 个顶点，$e$ 条边，所以空间使用情况为 $\rm O(n+e)$。列表如下：

   | 存储结构 | 时间复杂度   | 空间使用情况 |
   | -------- | ------------ | ------------ |
   | 邻接矩阵 | $\rm O(n^2)$ | $\rm O(n^2)$ |
   | 邻接表   | $\rm O(n+e)$ | $\rm O(n+e)$ |

   由此可见，一般情况下邻接表的建立算法的时间复杂度和空间使用均优于邻接矩阵。

2. *实现无向图（或有向图）的邻接矩阵和邻接表两种存储结构的相互转换算法。*

   **算法的实现位于下面的方法中：**

   ```C++
   List::Graph<V, E, directed> Matrix::Graph<V, E, directed>::toList();
   Matrix::Graph<V, E, directed> List::Graph<V, E, directed>::toMatrix();
   ```

3. *在上述两种存储结构上，分别实现无向图（或有向图）的深度优先搜索(递归和非递归)和广度优先搜索算法。并以适当的方式存储和展示相应的搜索结果， 包括：深度优先或广度优先生成森林（或生成树）、深度优先或广度优先序列和深度优先或广度优先编号。并分析搜索算法的时间复杂度和空间复杂度。*

   **算法的实现位于下面的方法中：**

   ```C++
   void DFS(); // 深度优先遍历（递归）
   void DFSNonRec(); // 深度优先遍历（非递归）
   void BFS(); // 广度优先遍历
   ```

   **搜索结果的存储：**

   ```C++
   vector<size_t> DFSNum; // 顶点的先深编号
   vector<V> DFSSeq; // 顶点的先深序列
   Forest<V> DFSTree; // 顶点的深度优先生成树
   vector<size_t> BFSNum; // 顶点的先广编号
   vector<V> BFSSeq; // 顶点的先广序列
   Forest<V> BFSTree; // 顶点的广度优先生成树
   ```

   **搜索结果的展示：**

   - `DFS`，`BFS`，本身打印序列
   - 调用 test.h 的`printVec` 函数打印序列和编号
   - 调用 `Forest` 类的 `show` 方法打印树，打印格式为 `P1(S1,S2,...),P2(...),...`
     其中 `P1` 为第一棵树的根节点，`S1,S2,...` 为 `P1` 的孩子，以`,`分隔，`P2,...` 为其他树

   **深度优先搜索算法的分析：**

   对于邻接矩阵存储，因为要遍历整个矩阵，所以时间复杂度为 $\rm O(n^2)$。需要辅助数组 `visited` 保存数组是否被访问，大小为 $\rm O(n)$，且需要栈来保存程序运行状态，栈的深度取决于生成树的高度，此高度不会超过 $\rm n$，所以总的空间复杂度为 $\rm O(n)$。

   对于邻接表存储，因为要遍历每个顶点及其每条邻边，所以时间复杂度为 $\rm O(n+e)$，需要辅助数组 `visited` 保存数组是否被访问，大小为 $\rm O(n)$，同样用到了栈，总空间复杂度 $\rm O(n)$。列表如下：

   | 存储结构 | 时间复杂度   | 空间复杂度 |
   | -------- | ------------ | ---------- |
   | 邻接矩阵 | $\rm O(n^2)$ | $\rm O(n)$ |
   | 邻接表   | $\rm O(n+e)$ | $\rm O(n)$ |

   **广度优先搜索算法的分析：**

   对于邻接矩阵存储，因为要遍历整个矩阵，所以时间复杂度为 $\rm O(n^2)$。需要辅助数组 `visited` 保存数组是否被访问，大小为 $\rm O(n)$，且需要一个辅助队列来保存已访问顶点，队列的大小不会超过 $\rm n$，所以总的空间复杂度为 $\rm O(n)$。

   对于邻接表存储，因为要遍历每个顶点及其每条邻边，所以时间复杂度为 $\rm O(n+e)$，需要辅助数组 `visited` 保存数组是否被访问，大小为 $\rm O(n)$，同样用到了队列，总空间复杂度 $\rm O(n)$。列表如下：

   | 存储结构 | 时间复杂度   | 空间复杂度 |
   | -------- | ------------ | ---------- |
   | 邻接矩阵 | $\rm O(n^2)$ | $\rm O(n)$ |
   | 邻接表   | $\rm O(n+e)$ | $\rm O(n)$ |

4. *（1）对于无向图，采用“邻接表”存储结构，设计和实现计算每个顶点度的算法，并分析其时间复杂度。或者，（2）对于有向图，采用“邻接表”存储结构，设计和实现计算每个顶点入度、 出度和度的算法，并分析其时间复杂度。*

   **算法的实现位于下面的方法中：**

   ```C++
   void Matrix::Graph<V, E, directed>::calcDeg();
   ```

   >  注：为了打印方便，这里把计算所有顶点的入度、出度和度的算法置于同一个方法中。但下面的分析均基于对**所有**顶点进行**单种度**的计算。

   **时间复杂度分析：**

   对于无向图，需要遍历所有顶点的所有邻边，时间复杂度 $\rm O(n+e)$。

   对于有向图，计算入度时，本程序选择用一个数组存放各结点的入度，这样只进行一次遍历就能得到所有顶点的入度，时间复杂度 $\rm O(n+e)$；如果不进行优化，则时间复杂度为 $\rm O(n(n+e))=O(n^2)$。计算出度时，需遍历所有顶点的所有邻边，时间复杂度 $\rm O(n+e)$。计算度数时，需分别得到入度和出度然后相加，时间复杂度仍为  $\rm O(n+e)$。列表如下：

   | 待求度的种类 | 时间复杂度                                    |
   | ------------ | --------------------------------------------- |
   | 入度         | $\rm O(n+e)$ ，若不使用辅助数组，$\rm O(n^2)$ |
   | 出度         | $\rm O(n+e)$                                  |
   | 度           | $\rm O(n+e)$                                  |

5. *以适当的方式输入图的顶点和边，并显示相应的结果。要求顶点不少于 10 个，边不少于 13 个。*

   输入方法：在 `main` 中将程序输入流重定向到 in.txt， 从而 `create` 方法可以直接从文件读取输入。本程序参考网站 https://graphonline.ru/ch/graphs_examples 提供的例子，绘制了两个具有代表性的测试图，其性质如下所示：

   | 图   | 有向/无向 | 顶点数 | 边数 | 是否（弱）连通 | 顶点数据类型 | 边数据类型 |
   | ---- | --------- | ------ | ---- | -------------- | ------------ | ---------- |
   | M    | 无向      | 25     | 28   | 否             | `string`     | `int`      |
   | L    | 有向      | 10     | 18   | 是             | `string`     | `int`      |

   在 `main` 中建立调用 `create` 建立好图后，传入 `testMatrixGraph` 或 `testListGraph` 函数进行测试并显示结果。程序运行的结果保存在 out.txt 中。此外，可以在网站上对运行结果的正确性进行验证，两图分别存于 https://graphonline.ru/ch/?graph=HrTSeDQOGCPUilYh 和 http://graphonline.ru/ch/?graph=xvYnonKnPSlnGVoo。
   
   > 注：输入文件 in.txt 由 Python 基于邻接矩阵生成。代码如下：
   >
   > ```python
   > def show_input(M):
   >     """M: 邻接矩阵
   >     """
   >     cnt = 0
   >     edge = []
   >     for i in range(len(M)):
   >         for j in range(len(M)):
   >             if M[i, j] != 0:
   >                 cnt+=1
   >                 edge.append((i, j, M[i, j]))
   >     print(len(M), cnt)
   >     for i in range(len(M)):
   >         print(f"v{i} ", end="")
   >     print()
   >     for i in edge:
   >         print(f"{i[0]} {i[1]} {i[2]}")
   > ```
   >
   > 对于邻接表存储，因为建立过程中输入边采用的是头插法，所以边的存储顺序正好与插入顺序相反。所以，为了结果的可验证性，将输入文件关于插入边的部分进行了反转。
